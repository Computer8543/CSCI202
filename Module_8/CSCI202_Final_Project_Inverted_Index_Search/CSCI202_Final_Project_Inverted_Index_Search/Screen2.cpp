/* Program Name: Screen2.cpp
*  Author: Generated by ChatGPT using prompts by Kyle Ingersoll
*  Date last updated: 12/3/2024
*  Purpose: To create method definitions for Screen 2.
*/

#include "Screen2.h"
#include <windows.h>
#include <fstream>
#include <sstream>
#include <CommCtrl.h> // For common controls

LRESULT CALLBACK Screen2WndProc(HWND, UINT, WPARAM, LPARAM);

Screen2* screen2Instance = nullptr; // To pass class context into WndProc

void Screen2::createScreen(HINSTANCE hInstance, const std::string& filePath) {
    // Initialize the inverted index and fuzzy matcher
    InvertedIndex invertedIndex;

    // Load the file into the InvertedIndex
    invertedIndex.addFile(filePath); // index the file

    // Initialize fuzzy matcher with the inverted index
    fuzzyMatcher = FuzzyMatcher(invertedIndex.getIndex());

    // Window class setup
    WNDCLASS wc = {};
    wc.lpfnWndProc = Screen2WndProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"Screen2Class";
    RegisterClass(&wc);

    // Set up the Windows GUI
    HWND hwnd = CreateWindow(L"Screen2Class", L"Search Text File", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, 800, 600, nullptr, nullptr, hInstance, nullptr);

    if (!hwnd) {
        MessageBox(nullptr, L"Screen 2 creation failed!", L"Error", MB_ICONERROR);
        return;
    }

    screen2Instance = this; // Allow access to the class from WndProc

    // UI elements for Screen 2
    CreateWindow(L"STATIC", L"Input word(s) you want to search for:", WS_VISIBLE | WS_CHILD,
        20, 20, 300, 20, hwnd, nullptr, hInstance, nullptr);

    hwndSearchBox = CreateWindow(L"EDIT", L"", WS_VISIBLE | WS_CHILD | WS_BORDER | ES_AUTOHSCROLL,
        20, 50, 300, 20, hwnd, (HMENU)1, hInstance, nullptr);

    CreateWindow(L"STATIC", L"Exact Results:", WS_VISIBLE | WS_CHILD,
        20, 90, 100, 20, hwnd, nullptr, hInstance, nullptr);

    hwndExactResults = CreateWindow(L"EDIT", L"", WS_VISIBLE | WS_CHILD | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL,
        20, 120, 350, 400, hwnd, (HMENU)2, hInstance, nullptr);

    CreateWindow(L"STATIC", L"Fuzzy Results:", WS_VISIBLE | WS_CHILD,
        400, 90, 100, 20, hwnd, nullptr, hInstance, nullptr);

    hwndFuzzyResults = CreateWindow(L"EDIT", L"", WS_VISIBLE | WS_CHILD | WS_BORDER | ES_MULTILINE | ES_AUTOVSCROLL,
        400, 120, 350, 400, hwnd, (HMENU)3, hInstance, nullptr);

    // Button to trigger search
    CreateWindow(L"BUTTON", L"Search", WS_VISIBLE | WS_CHILD,
        330, 50, 80, 20, hwnd, (HMENU)4, hInstance, nullptr);

    // Event handling for search box input
    switch (message) {
    case WM_COMMAND: {
        // Check if the search button was clicked
        if (LOWORD(wParam) == IDC_BUTTON_SEARCH) {
            wchar_t searchBuffer[256];
            GetWindowTextW(hwndSearchBox, searchBuffer, 256);

            std::wstring ws(searchBuffer);
            std::string searchTerm(ws.begin(), ws.end());

            // Perform exact and fuzzy searches
            std::set<int> exactMatches = invertedIndex.search(searchTerm);
            std::set<std::string> fuzzyMatches = fuzzyMatcher.match(searchTerm);

            // Highlight results in respective boxes
            highlightResults(exactMatches, hwndExactResultsBox, invertedIndex);
            highlightResults(fuzzyMatches, hwndFuzzyResultsBox, invertedIndex);
        }
        break;
    }

                   // Handle other messages here...

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

}

    ShowWindow(hwnd, SW_SHOW);
}

// Highlight matched results in a text box
void Screen2::highlightResults(HWND hwnd, const std::wstring& text, const std::vector<size_t>& positions) {
    // Set the full text in the box
    SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)text.c_str());

    // Highlight the matched words
    for (size_t pos : positions) {
        CHARRANGE range;
        range.cpMin = pos;
        range.cpMax = pos + 1; // Assuming highlighting single characters

        SendMessage(hwnd, EM_SETSEL, range.cpMin, range.cpMax);
        SendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&charFormat);
    }
}

// Perform search and update results
void Screen2::performSearch(HWND hwnd, const std::string& searchText) {
    // Perform exact match search
    std::vector<size_t> exactPositions = invertedIndex.search(searchText);

    // Convert text to wstring for the text box
    std::wstring fullText = L"Full text content goes here..."; // Load from file
    highlightResults(hwndExactResults, fullText, exactPositions);

    // Perform fuzzy match search
    std::vector<size_t> fuzzyPositions = fuzzyMatcher.search(searchText);
    highlightResults(hwndFuzzyResults, fullText, fuzzyPositions);
}

LRESULT CALLBACK Screen2WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_COMMAND:
        if (LOWORD(wParam) == 4) { // Search button clicked
            wchar_t buffer[256];
            GetWindowText(screen2Instance->hwndSearchBox, buffer, 256);

            // Convert wchar_t to std::string
            std::wstring ws(buffer);
            std::string searchText(ws.begin(), ws.end());

            // Perform the search
            screen2Instance->performSearch(hwnd, searchText);
        }
        break;

    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);
}

// Helper to highlight results
void Screen2::highlightResults(const std::set<int>& results, HWND hwndResultsBox, const InvertedIndex& index) {
    std::wstring text;
    GetWindowTextW(hwndResultsBox, text.data(), 8192);

    // For each match, highlight in the box
    for (int line : results) {
        // Retrieve corresponding line from the indexed document
        const std::string& lineText = index.getDocument(line);

        // Add highlighting logic (e.g., bold, underlining)
        // Note: Actual implementation will depend on rich text or custom rendering
    }

    SetWindowTextW(hwndResultsBox, text.c_str());
}