#ifndef AVL_TREE_H
#define AVL_TREE_H

/* Program name: avlTree.h
*  Author: Generated by ChatGPT using a prompt from Kyle Ingersoll
*  Date last updated: 11/30/2024
*  Purpose: To implement an AVL tree as a class in C++ using and altering as neccessary the functions given in avlTreeOriginal.h.
*/

#include <iostream>
using namespace std;

// Definition of the AVL Node
template<class elemType>
struct AVLNode {
    elemType info;
    int bfactor; // Balance factor
    AVLNode<elemType>* lLink;
    AVLNode<elemType>* rLink;

    AVLNode(elemType value)
        : info(value), bfactor(0), lLink(nullptr), rLink(nullptr) {}
};

// Definition of the AVL Tree class
template<class elemType>
class AVLTree {
private:
    AVLNode<elemType>* root;

    void rotateToLeft(AVLNode<elemType>*& root);
    void rotateToRight(AVLNode<elemType>*& root);
    void balanceFromLeft(AVLNode<elemType>*& root);
    void balanceFromRight(AVLNode<elemType>*& root);
    void insertIntoAVL(AVLNode<elemType>*& root, AVLNode<elemType>* newNode, bool& isTaller);
    void destroyTree(AVLNode<elemType>*& root);

    // Helper for traverse
    void inOrderTraversal(AVLNode<elemType>* root, ostream& out) const;

public:
    AVLTree();
    ~AVLTree();
    void insert(const elemType& newItem);
    void clear();
    bool isEmpty() const;
    void traverse(ostream& out = cout) const; // Default to in-order traversal
};

// Implementation of class member functions
template<class elemType>
AVLTree<elemType>::AVLTree() : root(nullptr) {}

template<class elemType>
AVLTree<elemType>::~AVLTree() {
    clear();
}

template<class elemType>
void AVLTree<elemType>::clear() {
    destroyTree(root);
    root = nullptr;
}

template<class elemType>
bool AVLTree<elemType>::isEmpty() const {
    return root == nullptr;
}

template<class elemType>
void AVLTree<elemType>::insert(const elemType& newItem) {
    bool isTaller = false;
    AVLNode<elemType>* newNode = new AVLNode<elemType>(newItem);
    insertIntoAVL(root, newNode, isTaller);
}

template<class elemType>
void AVLTree<elemType>::destroyTree(AVLNode<elemType>*& root) {
    if (root != nullptr) {
        destroyTree(root->lLink);
        destroyTree(root->rLink);
        delete root;
        root = nullptr;
    }
}

template<class elemType>
void AVLTree<elemType>::rotateToLeft(AVLNode<elemType>*& root) {
    if (root == nullptr || root->rLink == nullptr) {
        cout << "Error: Invalid rotation to the left." << endl;
        return;
    }
    AVLNode<elemType>* p = root->rLink;
    root->rLink = p->lLink;
    p->lLink = root;
    root = p;
}

template<class elemType>
void AVLTree<elemType>::rotateToRight(AVLNode<elemType>*& root) {
    if (root == nullptr || root->lLink == nullptr) {
        cout << "Error: Invalid rotation to the right." << endl;
        return;
    }
    AVLNode<elemType>* p = root->lLink;
    root->lLink = p->rLink;
    p->rLink = root;
    root = p;
}

template<class elemType>
void AVLTree<elemType>::balanceFromLeft(AVLNode<elemType>*& root) {
    AVLNode<elemType>* p = root->lLink;
    if (p->bfactor == -1) { // Left-heavy
        root->bfactor = p->bfactor = 0;
        rotateToRight(root);
    }
    else if (p->bfactor == 1) { // Left-Right case
        AVLNode<elemType>* w = p->rLink;
        switch (w->bfactor) {
        case -1: root->bfactor = 1; p->bfactor = 0; break;
        case 0: root->bfactor = p->bfactor = 0; break;
        case 1: root->bfactor = 0; p->bfactor = -1; break;
        }
        w->bfactor = 0;
        rotateToLeft(p);
        root->lLink = p;
        rotateToRight(root);
    }
}

template<class elemType>
void AVLTree<elemType>::balanceFromRight(AVLNode<elemType>*& root) {
    AVLNode<elemType>* p = root->rLink;
    if (p->bfactor == 1) { // Right-heavy
        root->bfactor = p->bfactor = 0;
        rotateToLeft(root);
    }
    else if (p->bfactor == -1) { // Right-Left case
        AVLNode<elemType>* w = p->lLink;
        switch (w->bfactor) {
        case -1: root->bfactor = 0; p->bfactor = 1; break;
        case 0: root->bfactor = p->bfactor = 0; break;
        case 1: root->bfactor = -1; p->bfactor = 0; break;
        }
        w->bfactor = 0;
        rotateToRight(p);
        root->rLink = p;
        rotateToLeft(root);
    }
}

template<class elemType>
void AVLTree<elemType>::insertIntoAVL(AVLNode<elemType>*& root, AVLNode<elemType>* newNode, bool& isTaller) {
    if (root == nullptr) {
        root = newNode;
        isTaller = true;
    }
    else if (newNode->info < root->info) {
        insertIntoAVL(root->lLink, newNode, isTaller);
        if (isTaller) {
            switch (root->bfactor) {
            case -1: balanceFromLeft(root); isTaller = false; break;
            case 0: root->bfactor = -1; break;
            case 1: root->bfactor = 0; isTaller = false; break;
            }
        }
    }
    else if (newNode->info > root->info) {
        insertIntoAVL(root->rLink, newNode, isTaller);
        if (isTaller) {
            switch (root->bfactor) {
            case -1: root->bfactor = 0; isTaller = false; break;
            case 0: root->bfactor = 1; break;
            case 1: balanceFromRight(root); isTaller = false; break;
            }
        }
    }
    else {
        cout << "No duplicates allowed." << endl;
    }
}

template<class elemType>
void AVLTree<elemType>::inOrderTraversal(AVLNode<elemType>* root, ostream& out) const {
    if (root != nullptr) {
        inOrderTraversal(root->lLink, out);
        out << root->info << " ";
        inOrderTraversal(root->rLink, out);
    }
}

// note: had to reprompt ChatGPT to create a traversal function to add to the AVL tree class
template<class elemType>
void AVLTree<elemType>::traverse(ostream& out) const {
    inOrderTraversal(root, out);
    out << endl;
}

#endif // AVL_TREE_H

